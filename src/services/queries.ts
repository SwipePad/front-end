/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Swipe Pad API
 * OpenAPI spec version: 0.0.12
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import type {
  AlbumControllerGetAlbumNamesParams,
  AlbumResponse,
  ChangeMigrateTimeDto,
  CommentControllerGetPaginationParams,
  CommentPaginationResponse,
  CommentResponse,
  CountMemeNoFeeRequestResponse,
  CreateAlbumDto,
  CreateAlbumRecordDto,
  CreateCommentDto,
  CreateFollowDto,
  CreateLikeMemeDto,
  CreateMemeNoFeeRequestResponse,
  CreateMemeOffChainDto,
  CreateMemeSwapRequestResponse,
  DashboardControllerQueryDeploymentChartParams,
  DashboardControllerQueryFeeChartParams,
  DashboardControllerQuerySubmissionChartParams,
  DashboardControllerQueryTransactionChartParams,
  DashboardControllerQueryUserCountChartParams,
  DashboardControllerQueryVolumeChartParams,
  DeleteAlbumDto,
  DeleteAlbumRecordDto,
  FileUploadControllerUploadSingleBody,
  FileUploadControllerUploadSingleIpfsBody,
  FollowPaginationResponse,
  FormattedTopHolderResponse,
  LoginDto,
  LoginMockDto,
  MemeControllerCreateSwapHumanModeParams,
  MemeControllerFindMultipleRandomParams,
  MemeControllerFindWatchListMultipleRandomParams,
  MemeControllerQueryPaginationParams,
  MemeControllerQueryTopCreatorsPaginationParams,
  MemeDetailResponse,
  MemePaginationResponse,
  OHLCResponse,
  RenameAlbumDto,
  ResponseClaimParamDto,
  SendWorldAppNotificationDto,
  TradeTransactionPaginationResponse,
  TransactionControllerFindParams,
  TransactionControllerGetPaginationParams,
  TransactionControllerGetUserActivityParams,
  UpdateMemeOffChainDto,
  UpdateUserDto,
  UserAndFollowStatusResponse,
  UserControllerFindFollowersPaginationParams,
  UserControllerFindFollowingPaginationParams,
  UserControllerFindPaginationParams,
  UserResponse,
  VerifyHumanDto,
} from "./models";

import { customClient } from "./custom-client";
import type { ErrorType, BodyType } from "./custom-client";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

export const healthCheckControllerHealthCheck = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>({ url: `/api/health-check`, method: "GET", signal }, options);
};

export const getHealthCheckControllerHealthCheckQueryKey = () => {
  return [`/api/health-check`] as const;
};

export const getHealthCheckControllerHealthCheckQueryOptions = <
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getHealthCheckControllerHealthCheckQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>> = ({
    signal,
  }) => healthCheckControllerHealthCheck(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckControllerHealthCheckQueryResult = NonNullable<
  Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>
>;
export type HealthCheckControllerHealthCheckQueryError = ErrorType<unknown>;

export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useHealthCheckControllerHealthCheck<
  TData = Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof healthCheckControllerHealthCheck>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getHealthCheckControllerHealthCheckQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const fileUploadControllerUploadSingle = (
  fileUploadControllerUploadSingleBody: BodyType<FileUploadControllerUploadSingleBody>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  if (fileUploadControllerUploadSingleBody.file !== undefined) {
    formData.append(`file`, fileUploadControllerUploadSingleBody.file);
  }

  return customClient<void>(
    {
      url: `/api/file-upload/offchain/single`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
      signal,
    },
    options
  );
};

export const getFileUploadControllerUploadSingleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
    TError,
    { data: BodyType<FileUploadControllerUploadSingleBody> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
  TError,
  { data: BodyType<FileUploadControllerUploadSingleBody> },
  TContext
> => {
  const mutationKey = ["fileUploadControllerUploadSingle"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
    { data: BodyType<FileUploadControllerUploadSingleBody> }
  > = props => {
    const { data } = props ?? {};

    return fileUploadControllerUploadSingle(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FileUploadControllerUploadSingleMutationResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>
>;
export type FileUploadControllerUploadSingleMutationBody =
  BodyType<FileUploadControllerUploadSingleBody>;
export type FileUploadControllerUploadSingleMutationError = ErrorType<unknown>;

export const useFileUploadControllerUploadSingle = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
      TError,
      { data: BodyType<FileUploadControllerUploadSingleBody> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingle>>,
  TError,
  { data: BodyType<FileUploadControllerUploadSingleBody> },
  TContext
> => {
  const mutationOptions = getFileUploadControllerUploadSingleMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const fileUploadControllerGet = (
  fileName: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<Blob>(
    { url: `/api/file-upload/offchain/${fileName}`, method: "GET", responseType: "blob", signal },
    options
  );
};

export const getFileUploadControllerGetQueryKey = (fileName: string) => {
  return [`/api/file-upload/offchain/${fileName}`] as const;
};

export const getFileUploadControllerGetQueryOptions = <
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileUploadControllerGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFileUploadControllerGetQueryKey(fileName);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof fileUploadControllerGet>>> = ({
    signal,
  }) => fileUploadControllerGet(fileName, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!fileName,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof fileUploadControllerGet>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type FileUploadControllerGetQueryResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerGet>>
>;
export type FileUploadControllerGetQueryError = ErrorType<unknown>;

export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileUploadControllerGet>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileUploadControllerGet>>,
          TError,
          Awaited<ReturnType<typeof fileUploadControllerGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileUploadControllerGet>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fileUploadControllerGet>>,
          TError,
          Awaited<ReturnType<typeof fileUploadControllerGet>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileUploadControllerGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useFileUploadControllerGet<
  TData = Awaited<ReturnType<typeof fileUploadControllerGet>>,
  TError = ErrorType<unknown>,
>(
  fileName: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof fileUploadControllerGet>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFileUploadControllerGetQueryOptions(fileName, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const fileUploadControllerUploadSingleIpfs = (
  fileUploadControllerUploadSingleIpfsBody: BodyType<FileUploadControllerUploadSingleIpfsBody>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  const formData = new FormData();
  if (fileUploadControllerUploadSingleIpfsBody.file !== undefined) {
    formData.append(`file`, fileUploadControllerUploadSingleIpfsBody.file);
  }

  return customClient<void>(
    {
      url: `/api/file-upload/ipfs/single`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
      signal,
    },
    options
  );
};

export const getFileUploadControllerUploadSingleIpfsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof fileUploadControllerUploadSingleIpfs>>,
    TError,
    { data: BodyType<FileUploadControllerUploadSingleIpfsBody> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingleIpfs>>,
  TError,
  { data: BodyType<FileUploadControllerUploadSingleIpfsBody> },
  TContext
> => {
  const mutationKey = ["fileUploadControllerUploadSingleIpfs"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof fileUploadControllerUploadSingleIpfs>>,
    { data: BodyType<FileUploadControllerUploadSingleIpfsBody> }
  > = props => {
    const { data } = props ?? {};

    return fileUploadControllerUploadSingleIpfs(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type FileUploadControllerUploadSingleIpfsMutationResult = NonNullable<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingleIpfs>>
>;
export type FileUploadControllerUploadSingleIpfsMutationBody =
  BodyType<FileUploadControllerUploadSingleIpfsBody>;
export type FileUploadControllerUploadSingleIpfsMutationError = ErrorType<unknown>;

export const useFileUploadControllerUploadSingleIpfs = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof fileUploadControllerUploadSingleIpfs>>,
      TError,
      { data: BodyType<FileUploadControllerUploadSingleIpfsBody> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof fileUploadControllerUploadSingleIpfs>>,
  TError,
  { data: BodyType<FileUploadControllerUploadSingleIpfsBody> },
  TContext
> => {
  const mutationOptions = getFileUploadControllerUploadSingleIpfsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const userControllerLogin = (
  loginDto: BodyType<LoginDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<string>(
    {
      url: `/api/user`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginDto,
      signal,
    },
    options
  );
};

export const getUserControllerLoginMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerLogin>>,
    TError,
    { data: BodyType<LoginDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerLogin>>,
  TError,
  { data: BodyType<LoginDto> },
  TContext
> => {
  const mutationKey = ["userControllerLogin"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerLogin>>,
    { data: BodyType<LoginDto> }
  > = props => {
    const { data } = props ?? {};

    return userControllerLogin(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerLoginMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerLogin>>
>;
export type UserControllerLoginMutationBody = BodyType<LoginDto>;
export type UserControllerLoginMutationError = ErrorType<unknown>;

export const useUserControllerLogin = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userControllerLogin>>,
      TError,
      { data: BodyType<LoginDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userControllerLogin>>,
  TError,
  { data: BodyType<LoginDto> },
  TContext
> => {
  const mutationOptions = getUserControllerLoginMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const userControllerUpdate = (
  updateUserDto: BodyType<UpdateUserDto>,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<UserResponse>(
    {
      url: `/api/user`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateUserDto,
    },
    options
  );
};

export const getUserControllerUpdateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerUpdate>>,
    TError,
    { data: BodyType<UpdateUserDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerUpdate>>,
  TError,
  { data: BodyType<UpdateUserDto> },
  TContext
> => {
  const mutationKey = ["userControllerUpdate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerUpdate>>,
    { data: BodyType<UpdateUserDto> }
  > = props => {
    const { data } = props ?? {};

    return userControllerUpdate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerUpdate>>
>;
export type UserControllerUpdateMutationBody = BodyType<UpdateUserDto>;
export type UserControllerUpdateMutationError = ErrorType<unknown>;

export const useUserControllerUpdate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userControllerUpdate>>,
      TError,
      { data: BodyType<UpdateUserDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userControllerUpdate>>,
  TError,
  { data: BodyType<UpdateUserDto> },
  TContext
> => {
  const mutationOptions = getUserControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const userControllerFindPagination = (
  params: UserControllerFindPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<FollowPaginationResponse>(
    { url: `/api/user`, method: "GET", params, signal },
    options
  );
};

export const getUserControllerFindPaginationQueryKey = (
  params: UserControllerFindPaginationParams
) => {
  return [`/api/user`, ...(params ? [params] : [])] as const;
};

export const getUserControllerFindPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerFindPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerFindPaginationQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindPagination>>> = ({
    signal,
  }) => userControllerFindPagination(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerFindPagination>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerFindPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFindPagination>>
>;
export type UserControllerFindPaginationQueryError = ErrorType<FollowPaginationResponse>;

export function useUserControllerFindPagination<
  TData = Awaited<ReturnType<typeof userControllerFindPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindPagination>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindPagination>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindPagination<
  TData = Awaited<ReturnType<typeof userControllerFindPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindPagination>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindPagination>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindPagination<
  TData = Awaited<ReturnType<typeof userControllerFindPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerFindPagination<
  TData = Awaited<ReturnType<typeof userControllerFindPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerFindPaginationQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const userControllerVerifyHuman = (
  verifyHumanDto: BodyType<VerifyHumanDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<boolean>(
    {
      url: `/api/user/verify-human`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: verifyHumanDto,
      signal,
    },
    options
  );
};

export const getUserControllerVerifyHumanMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerVerifyHuman>>,
    TError,
    { data: BodyType<VerifyHumanDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerVerifyHuman>>,
  TError,
  { data: BodyType<VerifyHumanDto> },
  TContext
> => {
  const mutationKey = ["userControllerVerifyHuman"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerVerifyHuman>>,
    { data: BodyType<VerifyHumanDto> }
  > = props => {
    const { data } = props ?? {};

    return userControllerVerifyHuman(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerVerifyHumanMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerVerifyHuman>>
>;
export type UserControllerVerifyHumanMutationBody = BodyType<VerifyHumanDto>;
export type UserControllerVerifyHumanMutationError = ErrorType<unknown>;

export const useUserControllerVerifyHuman = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userControllerVerifyHuman>>,
      TError,
      { data: BodyType<VerifyHumanDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userControllerVerifyHuman>>,
  TError,
  { data: BodyType<VerifyHumanDto> },
  TContext
> => {
  const mutationOptions = getUserControllerVerifyHumanMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const userControllerLoginMock = (
  loginMockDto: BodyType<LoginMockDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<string>(
    {
      url: `/api/user/mock`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: loginMockDto,
      signal,
    },
    options
  );
};

export const getUserControllerLoginMockMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerLoginMock>>,
    TError,
    { data: BodyType<LoginMockDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerLoginMock>>,
  TError,
  { data: BodyType<LoginMockDto> },
  TContext
> => {
  const mutationKey = ["userControllerLoginMock"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerLoginMock>>,
    { data: BodyType<LoginMockDto> }
  > = props => {
    const { data } = props ?? {};

    return userControllerLoginMock(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerLoginMockMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerLoginMock>>
>;
export type UserControllerLoginMockMutationBody = BodyType<LoginMockDto>;
export type UserControllerLoginMockMutationError = ErrorType<unknown>;

export const useUserControllerLoginMock = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userControllerLoginMock>>,
      TError,
      { data: BodyType<LoginMockDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userControllerLoginMock>>,
  TError,
  { data: BodyType<LoginMockDto> },
  TContext
> => {
  const mutationOptions = getUserControllerLoginMockMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const userControllerGetNonce = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<string>({ url: `/api/user/nonce`, method: "GET", signal }, options);
};

export const getUserControllerGetNonceQueryKey = () => {
  return [`/api/user/nonce`] as const;
};

export const getUserControllerGetNonceQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerGetNonce>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof userControllerGetNonce>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerGetNonceQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetNonce>>> = ({ signal }) =>
    userControllerGetNonce(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerGetNonce>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerGetNonceQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerGetNonce>>
>;
export type UserControllerGetNonceQueryError = ErrorType<unknown>;

export function useUserControllerGetNonce<
  TData = Awaited<ReturnType<typeof userControllerGetNonce>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetNonce>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetNonce>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetNonce>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerGetNonce<
  TData = Awaited<ReturnType<typeof userControllerGetNonce>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetNonce>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetNonce>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetNonce>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerGetNonce<
  TData = Awaited<ReturnType<typeof userControllerGetNonce>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetNonce>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerGetNonce<
  TData = Awaited<ReturnType<typeof userControllerGetNonce>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetNonce>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerGetNonceQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const userControllerFollow = (
  createFollowDto: BodyType<CreateFollowDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    {
      url: `/api/user/follow`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createFollowDto,
      signal,
    },
    options
  );
};

export const getUserControllerFollowMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof userControllerFollow>>,
    TError,
    { data: BodyType<CreateFollowDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof userControllerFollow>>,
  TError,
  { data: BodyType<CreateFollowDto> },
  TContext
> => {
  const mutationKey = ["userControllerFollow"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof userControllerFollow>>,
    { data: BodyType<CreateFollowDto> }
  > = props => {
    const { data } = props ?? {};

    return userControllerFollow(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UserControllerFollowMutationResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFollow>>
>;
export type UserControllerFollowMutationBody = BodyType<CreateFollowDto>;
export type UserControllerFollowMutationError = ErrorType<unknown>;

export const useUserControllerFollow = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof userControllerFollow>>,
      TError,
      { data: BodyType<CreateFollowDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof userControllerFollow>>,
  TError,
  { data: BodyType<CreateFollowDto> },
  TContext
> => {
  const mutationOptions = getUserControllerFollowMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const userControllerFindFollowersPagination = (
  params: UserControllerFindFollowersPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<FollowPaginationResponse>(
    { url: `/api/user/follower`, method: "GET", params, signal },
    options
  );
};

export const getUserControllerFindFollowersPaginationQueryKey = (
  params: UserControllerFindFollowersPaginationParams
) => {
  return [`/api/user/follower`, ...(params ? [params] : [])] as const;
};

export const getUserControllerFindFollowersPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowersPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserControllerFindFollowersPaginationQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userControllerFindFollowersPagination>>
  > = ({ signal }) => userControllerFindFollowersPagination(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerFindFollowersPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFindFollowersPagination>>
>;
export type UserControllerFindFollowersPaginationQueryError = ErrorType<FollowPaginationResponse>;

export function useUserControllerFindFollowersPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowersPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindFollowersPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindFollowersPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowersPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindFollowersPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindFollowersPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowersPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerFindFollowersPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowersPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowersPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerFindFollowersPaginationQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const userControllerFindFollowingPagination = (
  params: UserControllerFindFollowingPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<FollowPaginationResponse>(
    { url: `/api/user/following`, method: "GET", params, signal },
    options
  );
};

export const getUserControllerFindFollowingPaginationQueryKey = (
  params: UserControllerFindFollowingPaginationParams
) => {
  return [`/api/user/following`, ...(params ? [params] : [])] as const;
};

export const getUserControllerFindFollowingPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowingPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getUserControllerFindFollowingPaginationQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof userControllerFindFollowingPagination>>
  > = ({ signal }) => userControllerFindFollowingPagination(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerFindFollowingPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFindFollowingPagination>>
>;
export type UserControllerFindFollowingPaginationQueryError = ErrorType<FollowPaginationResponse>;

export function useUserControllerFindFollowingPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowingPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindFollowingPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindFollowingPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowingPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindFollowingPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindFollowingPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowingPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerFindFollowingPagination<
  TData = Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
  TError = ErrorType<FollowPaginationResponse>,
>(
  params: UserControllerFindFollowingPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof userControllerFindFollowingPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerFindFollowingPaginationQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const userControllerGetClaimFreeParam = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<ResponseClaimParamDto>(
    { url: `/api/user/claim-free-param`, method: "GET", signal },
    options
  );
};

export const getUserControllerGetClaimFreeParamQueryKey = () => {
  return [`/api/user/claim-free-param`] as const;
};

export const getUserControllerGetClaimFreeParamQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerGetClaimFreeParamQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>> = ({
    signal,
  }) => userControllerGetClaimFreeParam(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UserControllerGetClaimFreeParamQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>
>;
export type UserControllerGetClaimFreeParamQueryError = ErrorType<unknown>;

export function useUserControllerGetClaimFreeParam<
  TData = Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerGetClaimFreeParam<
  TData = Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
          TError,
          Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerGetClaimFreeParam<
  TData = Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerGetClaimFreeParam<
  TData = Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerGetClaimFreeParam>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerGetClaimFreeParamQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const userControllerResetClaimFree = (
  userAddress: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    { url: `/api/user/reset-claim-free/${userAddress}`, method: "GET", signal },
    options
  );
};

export const getUserControllerResetClaimFreeQueryKey = (userAddress: string) => {
  return [`/api/user/reset-claim-free/${userAddress}`] as const;
};

export const getUserControllerResetClaimFreeQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerResetClaimFree>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerResetClaimFree>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerResetClaimFreeQueryKey(userAddress);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerResetClaimFree>>> = ({
    signal,
  }) => userControllerResetClaimFree(userAddress, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userAddress,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof userControllerResetClaimFree>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type UserControllerResetClaimFreeQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerResetClaimFree>>
>;
export type UserControllerResetClaimFreeQueryError = ErrorType<unknown>;

export function useUserControllerResetClaimFree<
  TData = Awaited<ReturnType<typeof userControllerResetClaimFree>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerResetClaimFree>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerResetClaimFree>>,
          TError,
          Awaited<ReturnType<typeof userControllerResetClaimFree>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerResetClaimFree<
  TData = Awaited<ReturnType<typeof userControllerResetClaimFree>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerResetClaimFree>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerResetClaimFree>>,
          TError,
          Awaited<ReturnType<typeof userControllerResetClaimFree>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerResetClaimFree<
  TData = Awaited<ReturnType<typeof userControllerResetClaimFree>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerResetClaimFree>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerResetClaimFree<
  TData = Awaited<ReturnType<typeof userControllerResetClaimFree>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerResetClaimFree>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerResetClaimFreeQueryOptions(userAddress, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const userControllerFindOne = (
  userAddress: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<UserAndFollowStatusResponse>(
    { url: `/api/user/${userAddress}`, method: "GET", signal },
    options
  );
};

export const getUserControllerFindOneQueryKey = (userAddress: string) => {
  return [`/api/user/${userAddress}`] as const;
};

export const getUserControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getUserControllerFindOneQueryKey(userAddress);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof userControllerFindOne>>> = ({ signal }) =>
    userControllerFindOne(userAddress, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userAddress,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type UserControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof userControllerFindOne>>
>;
export type UserControllerFindOneQueryError = ErrorType<unknown>;

export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindOne>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof userControllerFindOne>>,
          TError,
          Awaited<ReturnType<typeof userControllerFindOne>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useUserControllerFindOne<
  TData = Awaited<ReturnType<typeof userControllerFindOne>>,
  TError = ErrorType<unknown>,
>(
  userAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof userControllerFindOne>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getUserControllerFindOneQueryOptions(userAddress, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerCreateOffChainData = (
  createMemeOffChainDto: BodyType<CreateMemeOffChainDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<string>(
    {
      url: `/api/meme`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createMemeOffChainDto,
      signal,
    },
    options
  );
};

export const getMemeControllerCreateOffChainDataMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
    TError,
    { data: BodyType<CreateMemeOffChainDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
  TError,
  { data: BodyType<CreateMemeOffChainDto> },
  TContext
> => {
  const mutationKey = ["memeControllerCreateOffChainData"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
    { data: BodyType<CreateMemeOffChainDto> }
  > = props => {
    const { data } = props ?? {};

    return memeControllerCreateOffChainData(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MemeControllerCreateOffChainDataMutationResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerCreateOffChainData>>
>;
export type MemeControllerCreateOffChainDataMutationBody = BodyType<CreateMemeOffChainDto>;
export type MemeControllerCreateOffChainDataMutationError = ErrorType<unknown>;

export const useMemeControllerCreateOffChainData = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
      TError,
      { data: BodyType<CreateMemeOffChainDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof memeControllerCreateOffChainData>>,
  TError,
  { data: BodyType<CreateMemeOffChainDto> },
  TContext
> => {
  const mutationOptions = getMemeControllerCreateOffChainDataMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const memeControllerUpdateOffChainData = (
  updateMemeOffChainDto: BodyType<UpdateMemeOffChainDto>,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<void>(
    {
      url: `/api/meme`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: updateMemeOffChainDto,
    },
    options
  );
};

export const getMemeControllerUpdateOffChainDataMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof memeControllerUpdateOffChainData>>,
    TError,
    { data: BodyType<UpdateMemeOffChainDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof memeControllerUpdateOffChainData>>,
  TError,
  { data: BodyType<UpdateMemeOffChainDto> },
  TContext
> => {
  const mutationKey = ["memeControllerUpdateOffChainData"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof memeControllerUpdateOffChainData>>,
    { data: BodyType<UpdateMemeOffChainDto> }
  > = props => {
    const { data } = props ?? {};

    return memeControllerUpdateOffChainData(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MemeControllerUpdateOffChainDataMutationResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerUpdateOffChainData>>
>;
export type MemeControllerUpdateOffChainDataMutationBody = BodyType<UpdateMemeOffChainDto>;
export type MemeControllerUpdateOffChainDataMutationError = ErrorType<unknown>;

export const useMemeControllerUpdateOffChainData = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof memeControllerUpdateOffChainData>>,
      TError,
      { data: BodyType<UpdateMemeOffChainDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof memeControllerUpdateOffChainData>>,
  TError,
  { data: BodyType<UpdateMemeOffChainDto> },
  TContext
> => {
  const mutationOptions = getMemeControllerUpdateOffChainDataMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const memeControllerQueryPagination = (
  params: MemeControllerQueryPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<MemePaginationResponse>(
    { url: `/api/meme`, method: "GET", params, signal },
    options
  );
};

export const getMemeControllerQueryPaginationQueryKey = (
  params: MemeControllerQueryPaginationParams
) => {
  return [`/api/meme`, ...(params ? [params] : [])] as const;
};

export const getMemeControllerQueryPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerQueryPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerQueryPaginationQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerQueryPagination>>> = ({
    signal,
  }) => memeControllerQueryPagination(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerQueryPagination>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerQueryPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerQueryPagination>>
>;
export type MemeControllerQueryPaginationQueryError = ErrorType<unknown>;

export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerQueryPagination>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerQueryPagination>>,
          TError,
          Awaited<ReturnType<typeof memeControllerQueryPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerQueryPagination>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerQueryPagination>>,
          TError,
          Awaited<ReturnType<typeof memeControllerQueryPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerQueryPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerQueryPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerQueryPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerQueryPaginationQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerCreateMemeNoFeeRequest = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<CreateMemeNoFeeRequestResponse>(
    { url: `/api/meme/request/create-meme-no-fee`, method: "GET", signal },
    options
  );
};

export const getMemeControllerCreateMemeNoFeeRequestQueryKey = () => {
  return [`/api/meme/request/create-meme-no-fee`] as const;
};

export const getMemeControllerCreateMemeNoFeeRequestQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerCreateMemeNoFeeRequestQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>
  > = ({ signal }) => memeControllerCreateMemeNoFeeRequest(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerCreateMemeNoFeeRequestQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>
>;
export type MemeControllerCreateMemeNoFeeRequestQueryError = ErrorType<unknown>;

export function useMemeControllerCreateMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
          TError,
          Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerCreateMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
          TError,
          Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerCreateMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerCreateMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCreateMemeNoFeeRequest>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerCreateMemeNoFeeRequestQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerCountMemeNoFeeRequest = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<CountMemeNoFeeRequestResponse>(
    { url: `/api/meme/request/create-meme-no-fee/count`, method: "GET", signal },
    options
  );
};

export const getMemeControllerCountMemeNoFeeRequestQueryKey = () => {
  return [`/api/meme/request/create-meme-no-fee/count`] as const;
};

export const getMemeControllerCountMemeNoFeeRequestQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerCountMemeNoFeeRequestQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>> = ({
    signal,
  }) => memeControllerCountMemeNoFeeRequest(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerCountMemeNoFeeRequestQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>
>;
export type MemeControllerCountMemeNoFeeRequestQueryError = ErrorType<unknown>;

export function useMemeControllerCountMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
          TError,
          Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerCountMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
          TError,
          Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerCountMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerCountMemeNoFeeRequest<
  TData = Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerCountMemeNoFeeRequest>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerCountMemeNoFeeRequestQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerCreateSwapHumanMode = (
  params: MemeControllerCreateSwapHumanModeParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<CreateMemeSwapRequestResponse>(
    { url: `/api/meme/request/swap-human-mode`, method: "GET", params, signal },
    options
  );
};

export const getMemeControllerCreateSwapHumanModeQueryKey = (
  params: MemeControllerCreateSwapHumanModeParams
) => {
  return [`/api/meme/request/swap-human-mode`, ...(params ? [params] : [])] as const;
};

export const getMemeControllerCreateSwapHumanModeQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerCreateSwapHumanModeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerCreateSwapHumanModeQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>> = ({
    signal,
  }) => memeControllerCreateSwapHumanMode(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerCreateSwapHumanModeQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>
>;
export type MemeControllerCreateSwapHumanModeQueryError = ErrorType<unknown>;

export function useMemeControllerCreateSwapHumanMode<
  TData = Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerCreateSwapHumanModeParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
          TError,
          Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerCreateSwapHumanMode<
  TData = Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerCreateSwapHumanModeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
          TError,
          Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerCreateSwapHumanMode<
  TData = Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerCreateSwapHumanModeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerCreateSwapHumanMode<
  TData = Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerCreateSwapHumanModeParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerCreateSwapHumanMode>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerCreateSwapHumanModeQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerFindRandom = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<MemeDetailResponse>(
    { url: `/api/meme/random`, method: "GET", signal },
    options
  );
};

export const getMemeControllerFindRandomQueryKey = () => {
  return [`/api/meme/random`] as const;
};

export const getMemeControllerFindRandomQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerFindRandom>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindRandom>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerFindRandomQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerFindRandom>>> = ({
    signal,
  }) => memeControllerFindRandom(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerFindRandom>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerFindRandomQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerFindRandom>>
>;
export type MemeControllerFindRandomQueryError = ErrorType<unknown>;

export function useMemeControllerFindRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindRandom>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindRandom>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindRandom>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindRandom>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindRandom>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindRandom>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindRandom>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindRandom>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindRandom>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindRandom>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerFindRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindRandom>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindRandom>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerFindRandomQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerFindMultipleRandom = (
  params: MemeControllerFindMultipleRandomParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<MemeDetailResponse[]>(
    { url: `/api/meme/multiple-random`, method: "GET", params, signal },
    options
  );
};

export const getMemeControllerFindMultipleRandomQueryKey = (
  params: MemeControllerFindMultipleRandomParams
) => {
  return [`/api/meme/multiple-random`, ...(params ? [params] : [])] as const;
};

export const getMemeControllerFindMultipleRandomQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerFindMultipleRandomQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>> = ({
    signal,
  }) => memeControllerFindMultipleRandom(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerFindMultipleRandomQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>
>;
export type MemeControllerFindMultipleRandomQueryError = ErrorType<unknown>;

export function useMemeControllerFindMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindMultipleRandomParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerFindMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindMultipleRandom>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerFindMultipleRandomQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerFindWatchListMultipleRandom = (
  params: MemeControllerFindWatchListMultipleRandomParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<MemeDetailResponse[]>(
    { url: `/api/meme/watchlist/multiple-random`, method: "GET", params, signal },
    options
  );
};

export const getMemeControllerFindWatchListMultipleRandomQueryKey = (
  params: MemeControllerFindWatchListMultipleRandomParams
) => {
  return [`/api/meme/watchlist/multiple-random`, ...(params ? [params] : [])] as const;
};

export const getMemeControllerFindWatchListMultipleRandomQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindWatchListMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMemeControllerFindWatchListMultipleRandomQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>
  > = ({ signal }) => memeControllerFindWatchListMultipleRandom(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerFindWatchListMultipleRandomQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>
>;
export type MemeControllerFindWatchListMultipleRandomQueryError = ErrorType<unknown>;

export function useMemeControllerFindWatchListMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindWatchListMultipleRandomParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindWatchListMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindWatchListMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindWatchListMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindWatchListMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerFindWatchListMultipleRandom<
  TData = Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerFindWatchListMultipleRandomParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerFindWatchListMultipleRandom>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerFindWatchListMultipleRandomQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerLikeMeme = (
  createLikeMemeDto: BodyType<CreateLikeMemeDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    {
      url: `/api/meme/like`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createLikeMemeDto,
      signal,
    },
    options
  );
};

export const getMemeControllerLikeMemeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof memeControllerLikeMeme>>,
    TError,
    { data: BodyType<CreateLikeMemeDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof memeControllerLikeMeme>>,
  TError,
  { data: BodyType<CreateLikeMemeDto> },
  TContext
> => {
  const mutationKey = ["memeControllerLikeMeme"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof memeControllerLikeMeme>>,
    { data: BodyType<CreateLikeMemeDto> }
  > = props => {
    const { data } = props ?? {};

    return memeControllerLikeMeme(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MemeControllerLikeMemeMutationResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerLikeMeme>>
>;
export type MemeControllerLikeMemeMutationBody = BodyType<CreateLikeMemeDto>;
export type MemeControllerLikeMemeMutationError = ErrorType<unknown>;

export const useMemeControllerLikeMeme = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof memeControllerLikeMeme>>,
      TError,
      { data: BodyType<CreateLikeMemeDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof memeControllerLikeMeme>>,
  TError,
  { data: BodyType<CreateLikeMemeDto> },
  TContext
> => {
  const mutationOptions = getMemeControllerLikeMemeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const memeControllerChangeMigrateTime = (
  changeMigrateTimeDto: BodyType<ChangeMigrateTimeDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    {
      url: `/api/meme/change-migrate-time`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: changeMigrateTimeDto,
      signal,
    },
    options
  );
};

export const getMemeControllerChangeMigrateTimeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof memeControllerChangeMigrateTime>>,
    TError,
    { data: BodyType<ChangeMigrateTimeDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof memeControllerChangeMigrateTime>>,
  TError,
  { data: BodyType<ChangeMigrateTimeDto> },
  TContext
> => {
  const mutationKey = ["memeControllerChangeMigrateTime"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof memeControllerChangeMigrateTime>>,
    { data: BodyType<ChangeMigrateTimeDto> }
  > = props => {
    const { data } = props ?? {};

    return memeControllerChangeMigrateTime(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MemeControllerChangeMigrateTimeMutationResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerChangeMigrateTime>>
>;
export type MemeControllerChangeMigrateTimeMutationBody = BodyType<ChangeMigrateTimeDto>;
export type MemeControllerChangeMigrateTimeMutationError = ErrorType<unknown>;

export const useMemeControllerChangeMigrateTime = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof memeControllerChangeMigrateTime>>,
      TError,
      { data: BodyType<ChangeMigrateTimeDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof memeControllerChangeMigrateTime>>,
  TError,
  { data: BodyType<ChangeMigrateTimeDto> },
  TContext
> => {
  const mutationOptions = getMemeControllerChangeMigrateTimeMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const memeControllerQueryTopCreatorsPagination = (
  params: MemeControllerQueryTopCreatorsPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<FollowPaginationResponse>(
    { url: `/api/meme/top-creators`, method: "GET", params, signal },
    options
  );
};

export const getMemeControllerQueryTopCreatorsPaginationQueryKey = (
  params: MemeControllerQueryTopCreatorsPaginationParams
) => {
  return [`/api/meme/top-creators`, ...(params ? [params] : [])] as const;
};

export const getMemeControllerQueryTopCreatorsPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryTopCreatorsPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getMemeControllerQueryTopCreatorsPaginationQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>
  > = ({ signal }) => memeControllerQueryTopCreatorsPagination(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerQueryTopCreatorsPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>
>;
export type MemeControllerQueryTopCreatorsPaginationQueryError = ErrorType<unknown>;

export function useMemeControllerQueryTopCreatorsPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryTopCreatorsPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
          TError,
          Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerQueryTopCreatorsPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryTopCreatorsPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
          TError,
          Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerQueryTopCreatorsPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryTopCreatorsPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerQueryTopCreatorsPagination<
  TData = Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
  TError = ErrorType<unknown>,
>(
  params: MemeControllerQueryTopCreatorsPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof memeControllerQueryTopCreatorsPagination>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerQueryTopCreatorsPaginationQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerGetQuotePrice = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>({ url: `/api/meme/quote-price`, method: "GET", signal }, options);
};

export const getMemeControllerGetQuotePriceQueryKey = () => {
  return [`/api/meme/quote-price`] as const;
};

export const getMemeControllerGetQuotePriceQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof memeControllerGetQuotePrice>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerGetQuotePriceQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerGetQuotePrice>>> = ({
    signal,
  }) => memeControllerGetQuotePrice(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MemeControllerGetQuotePriceQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerGetQuotePrice>>
>;
export type MemeControllerGetQuotePriceQueryError = ErrorType<unknown>;

export function useMemeControllerGetQuotePrice<
  TData = Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerGetQuotePrice>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
          TError,
          Awaited<ReturnType<typeof memeControllerGetQuotePrice>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerGetQuotePrice<
  TData = Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerGetQuotePrice>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
          TError,
          Awaited<ReturnType<typeof memeControllerGetQuotePrice>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerGetQuotePrice<
  TData = Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerGetQuotePrice>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerGetQuotePrice<
  TData = Awaited<ReturnType<typeof memeControllerGetQuotePrice>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerGetQuotePrice>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerGetQuotePriceQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerFindTopHolders = (
  tokenAddress: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<FormattedTopHolderResponse[]>(
    { url: `/api/meme/top-holders/${tokenAddress}`, method: "GET", signal },
    options
  );
};

export const getMemeControllerFindTopHoldersQueryKey = (tokenAddress: string) => {
  return [`/api/meme/top-holders/${tokenAddress}`] as const;
};

export const getMemeControllerFindTopHoldersQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerFindTopHolders>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindTopHolders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerFindTopHoldersQueryKey(tokenAddress);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerFindTopHolders>>> = ({
    signal,
  }) => memeControllerFindTopHolders(tokenAddress, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!tokenAddress,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindTopHolders>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type MemeControllerFindTopHoldersQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerFindTopHolders>>
>;
export type MemeControllerFindTopHoldersQueryError = ErrorType<unknown>;

export function useMemeControllerFindTopHolders<
  TData = Awaited<ReturnType<typeof memeControllerFindTopHolders>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindTopHolders>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindTopHolders>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindTopHolders>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindTopHolders<
  TData = Awaited<ReturnType<typeof memeControllerFindTopHolders>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindTopHolders>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindTopHolders>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindTopHolders>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindTopHolders<
  TData = Awaited<ReturnType<typeof memeControllerFindTopHolders>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindTopHolders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerFindTopHolders<
  TData = Awaited<ReturnType<typeof memeControllerFindTopHolders>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindTopHolders>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerFindTopHoldersQueryOptions(tokenAddress, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const memeControllerSendNotifications = (
  sendWorldAppNotificationDto: BodyType<SendWorldAppNotificationDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    {
      url: `/api/meme/send-notifications`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: sendWorldAppNotificationDto,
      signal,
    },
    options
  );
};

export const getMemeControllerSendNotificationsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof memeControllerSendNotifications>>,
    TError,
    { data: BodyType<SendWorldAppNotificationDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof memeControllerSendNotifications>>,
  TError,
  { data: BodyType<SendWorldAppNotificationDto> },
  TContext
> => {
  const mutationKey = ["memeControllerSendNotifications"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof memeControllerSendNotifications>>,
    { data: BodyType<SendWorldAppNotificationDto> }
  > = props => {
    const { data } = props ?? {};

    return memeControllerSendNotifications(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type MemeControllerSendNotificationsMutationResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerSendNotifications>>
>;
export type MemeControllerSendNotificationsMutationBody = BodyType<SendWorldAppNotificationDto>;
export type MemeControllerSendNotificationsMutationError = ErrorType<unknown>;

export const useMemeControllerSendNotifications = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof memeControllerSendNotifications>>,
      TError,
      { data: BodyType<SendWorldAppNotificationDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof memeControllerSendNotifications>>,
  TError,
  { data: BodyType<SendWorldAppNotificationDto> },
  TContext
> => {
  const mutationOptions = getMemeControllerSendNotificationsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const memeControllerFindDetail = (
  tokenAddress: string,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<MemeDetailResponse>(
    { url: `/api/meme/${tokenAddress}`, method: "GET", signal },
    options
  );
};

export const getMemeControllerFindDetailQueryKey = (tokenAddress: string) => {
  return [`/api/meme/${tokenAddress}`] as const;
};

export const getMemeControllerFindDetailQueryOptions = <
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getMemeControllerFindDetailQueryKey(tokenAddress);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof memeControllerFindDetail>>> = ({
    signal,
  }) => memeControllerFindDetail(tokenAddress, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!tokenAddress,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindDetail>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type MemeControllerFindDetailQueryResult = NonNullable<
  Awaited<ReturnType<typeof memeControllerFindDetail>>
>;
export type MemeControllerFindDetailQueryError = ErrorType<unknown>;

export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindDetail>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindDetail>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindDetail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindDetail>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof memeControllerFindDetail>>,
          TError,
          Awaited<ReturnType<typeof memeControllerFindDetail>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useMemeControllerFindDetail<
  TData = Awaited<ReturnType<typeof memeControllerFindDetail>>,
  TError = ErrorType<unknown>,
>(
  tokenAddress: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof memeControllerFindDetail>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getMemeControllerFindDetailQueryOptions(tokenAddress, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const transactionControllerGetPagination = (
  params: TransactionControllerGetPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<TradeTransactionPaginationResponse>(
    { url: `/api/transaction`, method: "GET", params, signal },
    options
  );
};

export const getTransactionControllerGetPaginationQueryKey = (
  params: TransactionControllerGetPaginationParams
) => {
  return [`/api/transaction`, ...(params ? [params] : [])] as const;
};

export const getTransactionControllerGetPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTransactionControllerGetPaginationQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerGetPagination>>> = ({
    signal,
  }) => transactionControllerGetPagination(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transactionControllerGetPagination>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TransactionControllerGetPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionControllerGetPagination>>
>;
export type TransactionControllerGetPaginationQueryError = ErrorType<unknown>;

export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetPagination>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetPagination>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerGetPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetPagination>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetPagination>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerGetPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useTransactionControllerGetPagination<
  TData = Awaited<ReturnType<typeof transactionControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerGetPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTransactionControllerGetPaginationQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const transactionControllerGetUserActivity = (
  params: TransactionControllerGetUserActivityParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<TradeTransactionPaginationResponse>(
    { url: `/api/transaction/user-activity`, method: "GET", params, signal },
    options
  );
};

export const getTransactionControllerGetUserActivityQueryKey = (
  params: TransactionControllerGetUserActivityParams
) => {
  return [`/api/transaction/user-activity`, ...(params ? [params] : [])] as const;
};

export const getTransactionControllerGetUserActivityQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetUserActivityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getTransactionControllerGetUserActivityQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof transactionControllerGetUserActivity>>
  > = ({ signal }) => transactionControllerGetUserActivity(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TransactionControllerGetUserActivityQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionControllerGetUserActivity>>
>;
export type TransactionControllerGetUserActivityQueryError = ErrorType<unknown>;

export function useTransactionControllerGetUserActivity<
  TData = Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetUserActivityParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerGetUserActivity>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTransactionControllerGetUserActivity<
  TData = Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetUserActivityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerGetUserActivity>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTransactionControllerGetUserActivity<
  TData = Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetUserActivityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useTransactionControllerGetUserActivity<
  TData = Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerGetUserActivityParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof transactionControllerGetUserActivity>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTransactionControllerGetUserActivityQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const transactionControllerFind = (
  params: TransactionControllerFindParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<OHLCResponse[]>(
    { url: `/api/transaction/charts`, method: "GET", params, signal },
    options
  );
};

export const getTransactionControllerFindQueryKey = (params: TransactionControllerFindParams) => {
  return [`/api/transaction/charts`, ...(params ? [params] : [])] as const;
};

export const getTransactionControllerFindQueryOptions = <
  TData = Awaited<ReturnType<typeof transactionControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFind>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getTransactionControllerFindQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof transactionControllerFind>>> = ({
    signal,
  }) => transactionControllerFind(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof transactionControllerFind>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type TransactionControllerFindQueryResult = NonNullable<
  Awaited<ReturnType<typeof transactionControllerFind>>
>;
export type TransactionControllerFindQueryError = ErrorType<unknown>;

export function useTransactionControllerFind<
  TData = Awaited<ReturnType<typeof transactionControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerFindParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFind>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerFind>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerFind>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTransactionControllerFind<
  TData = Awaited<ReturnType<typeof transactionControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFind>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof transactionControllerFind>>,
          TError,
          Awaited<ReturnType<typeof transactionControllerFind>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useTransactionControllerFind<
  TData = Awaited<ReturnType<typeof transactionControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFind>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useTransactionControllerFind<
  TData = Awaited<ReturnType<typeof transactionControllerFind>>,
  TError = ErrorType<unknown>,
>(
  params: TransactionControllerFindParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof transactionControllerFind>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getTransactionControllerFindQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const commentControllerCreate = (
  createCommentDto: BodyType<CreateCommentDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<CommentResponse>(
    {
      url: `/api/comment`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createCommentDto,
      signal,
    },
    options
  );
};

export const getCommentControllerCreateMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof commentControllerCreate>>,
    TError,
    { data: BodyType<CreateCommentDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof commentControllerCreate>>,
  TError,
  { data: BodyType<CreateCommentDto> },
  TContext
> => {
  const mutationKey = ["commentControllerCreate"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof commentControllerCreate>>,
    { data: BodyType<CreateCommentDto> }
  > = props => {
    const { data } = props ?? {};

    return commentControllerCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CommentControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof commentControllerCreate>>
>;
export type CommentControllerCreateMutationBody = BodyType<CreateCommentDto>;
export type CommentControllerCreateMutationError = ErrorType<unknown>;

export const useCommentControllerCreate = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof commentControllerCreate>>,
      TError,
      { data: BodyType<CreateCommentDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof commentControllerCreate>>,
  TError,
  { data: BodyType<CreateCommentDto> },
  TContext
> => {
  const mutationOptions = getCommentControllerCreateMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const commentControllerGetPagination = (
  params: CommentControllerGetPaginationParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<CommentPaginationResponse>(
    { url: `/api/comment`, method: "GET", params, signal },
    options
  );
};

export const getCommentControllerGetPaginationQueryKey = (
  params: CommentControllerGetPaginationParams
) => {
  return [`/api/comment`, ...(params ? [params] : [])] as const;
};

export const getCommentControllerGetPaginationQueryOptions = <
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commentControllerGetPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getCommentControllerGetPaginationQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof commentControllerGetPagination>>> = ({
    signal,
  }) => commentControllerGetPagination(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof commentControllerGetPagination>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CommentControllerGetPaginationQueryResult = NonNullable<
  Awaited<ReturnType<typeof commentControllerGetPagination>>
>;
export type CommentControllerGetPaginationQueryError = ErrorType<unknown>;

export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commentControllerGetPagination>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof commentControllerGetPagination>>,
          TError,
          Awaited<ReturnType<typeof commentControllerGetPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commentControllerGetPagination>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof commentControllerGetPagination>>,
          TError,
          Awaited<ReturnType<typeof commentControllerGetPagination>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commentControllerGetPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useCommentControllerGetPagination<
  TData = Awaited<ReturnType<typeof commentControllerGetPagination>>,
  TError = ErrorType<unknown>,
>(
  params: CommentControllerGetPaginationParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof commentControllerGetPagination>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getCommentControllerGetPaginationQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const albumControllerCreateAlbum = (
  createAlbumDto: BodyType<CreateAlbumDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    {
      url: `/api/album/album`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createAlbumDto,
      signal,
    },
    options
  );
};

export const getAlbumControllerCreateAlbumMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof albumControllerCreateAlbum>>,
    TError,
    { data: BodyType<CreateAlbumDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof albumControllerCreateAlbum>>,
  TError,
  { data: BodyType<CreateAlbumDto> },
  TContext
> => {
  const mutationKey = ["albumControllerCreateAlbum"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof albumControllerCreateAlbum>>,
    { data: BodyType<CreateAlbumDto> }
  > = props => {
    const { data } = props ?? {};

    return albumControllerCreateAlbum(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AlbumControllerCreateAlbumMutationResult = NonNullable<
  Awaited<ReturnType<typeof albumControllerCreateAlbum>>
>;
export type AlbumControllerCreateAlbumMutationBody = BodyType<CreateAlbumDto>;
export type AlbumControllerCreateAlbumMutationError = ErrorType<unknown>;

export const useAlbumControllerCreateAlbum = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof albumControllerCreateAlbum>>,
      TError,
      { data: BodyType<CreateAlbumDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof albumControllerCreateAlbum>>,
  TError,
  { data: BodyType<CreateAlbumDto> },
  TContext
> => {
  const mutationOptions = getAlbumControllerCreateAlbumMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const albumControllerGetAlbumNames = (
  params: AlbumControllerGetAlbumNamesParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<AlbumResponse[]>(
    { url: `/api/album/album`, method: "GET", params, signal },
    options
  );
};

export const getAlbumControllerGetAlbumNamesQueryKey = (
  params: AlbumControllerGetAlbumNamesParams
) => {
  return [`/api/album/album`, ...(params ? [params] : [])] as const;
};

export const getAlbumControllerGetAlbumNamesQueryOptions = <
  TData = Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
  TError = ErrorType<unknown>,
>(
  params: AlbumControllerGetAlbumNamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumControllerGetAlbumNames>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getAlbumControllerGetAlbumNamesQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof albumControllerGetAlbumNames>>> = ({
    signal,
  }) => albumControllerGetAlbumNames(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AlbumControllerGetAlbumNamesQueryResult = NonNullable<
  Awaited<ReturnType<typeof albumControllerGetAlbumNames>>
>;
export type AlbumControllerGetAlbumNamesQueryError = ErrorType<unknown>;

export function useAlbumControllerGetAlbumNames<
  TData = Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
  TError = ErrorType<unknown>,
>(
  params: AlbumControllerGetAlbumNamesParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumControllerGetAlbumNames>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
          TError,
          Awaited<ReturnType<typeof albumControllerGetAlbumNames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAlbumControllerGetAlbumNames<
  TData = Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
  TError = ErrorType<unknown>,
>(
  params: AlbumControllerGetAlbumNamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumControllerGetAlbumNames>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
          TError,
          Awaited<ReturnType<typeof albumControllerGetAlbumNames>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useAlbumControllerGetAlbumNames<
  TData = Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
  TError = ErrorType<unknown>,
>(
  params: AlbumControllerGetAlbumNamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumControllerGetAlbumNames>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useAlbumControllerGetAlbumNames<
  TData = Awaited<ReturnType<typeof albumControllerGetAlbumNames>>,
  TError = ErrorType<unknown>,
>(
  params: AlbumControllerGetAlbumNamesParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof albumControllerGetAlbumNames>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getAlbumControllerGetAlbumNamesQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const albumControllerAddOrRemoveRecordAlbum = (
  createAlbumRecordDto: BodyType<CreateAlbumRecordDto>,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    {
      url: `/api/album/record`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createAlbumRecordDto,
      signal,
    },
    options
  );
};

export const getAlbumControllerAddOrRemoveRecordAlbumMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof albumControllerAddOrRemoveRecordAlbum>>,
    TError,
    { data: BodyType<CreateAlbumRecordDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof albumControllerAddOrRemoveRecordAlbum>>,
  TError,
  { data: BodyType<CreateAlbumRecordDto> },
  TContext
> => {
  const mutationKey = ["albumControllerAddOrRemoveRecordAlbum"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof albumControllerAddOrRemoveRecordAlbum>>,
    { data: BodyType<CreateAlbumRecordDto> }
  > = props => {
    const { data } = props ?? {};

    return albumControllerAddOrRemoveRecordAlbum(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AlbumControllerAddOrRemoveRecordAlbumMutationResult = NonNullable<
  Awaited<ReturnType<typeof albumControllerAddOrRemoveRecordAlbum>>
>;
export type AlbumControllerAddOrRemoveRecordAlbumMutationBody = BodyType<CreateAlbumRecordDto>;
export type AlbumControllerAddOrRemoveRecordAlbumMutationError = ErrorType<unknown>;

export const useAlbumControllerAddOrRemoveRecordAlbum = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof albumControllerAddOrRemoveRecordAlbum>>,
      TError,
      { data: BodyType<CreateAlbumRecordDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof albumControllerAddOrRemoveRecordAlbum>>,
  TError,
  { data: BodyType<CreateAlbumRecordDto> },
  TContext
> => {
  const mutationOptions = getAlbumControllerAddOrRemoveRecordAlbumMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const albumControllerRemoveAlbum = (
  deleteAlbumDto: BodyType<DeleteAlbumDto>,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<void>(
    {
      url: `/api/album/remove`,
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      data: deleteAlbumDto,
    },
    options
  );
};

export const getAlbumControllerRemoveAlbumMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof albumControllerRemoveAlbum>>,
    TError,
    { data: BodyType<DeleteAlbumDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof albumControllerRemoveAlbum>>,
  TError,
  { data: BodyType<DeleteAlbumDto> },
  TContext
> => {
  const mutationKey = ["albumControllerRemoveAlbum"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof albumControllerRemoveAlbum>>,
    { data: BodyType<DeleteAlbumDto> }
  > = props => {
    const { data } = props ?? {};

    return albumControllerRemoveAlbum(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AlbumControllerRemoveAlbumMutationResult = NonNullable<
  Awaited<ReturnType<typeof albumControllerRemoveAlbum>>
>;
export type AlbumControllerRemoveAlbumMutationBody = BodyType<DeleteAlbumDto>;
export type AlbumControllerRemoveAlbumMutationError = ErrorType<unknown>;

export const useAlbumControllerRemoveAlbum = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof albumControllerRemoveAlbum>>,
      TError,
      { data: BodyType<DeleteAlbumDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof albumControllerRemoveAlbum>>,
  TError,
  { data: BodyType<DeleteAlbumDto> },
  TContext
> => {
  const mutationOptions = getAlbumControllerRemoveAlbumMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const albumControllerRemoveAlbumRecords = (
  deleteAlbumRecordDto: BodyType<DeleteAlbumRecordDto>,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<void>(
    {
      url: `/api/album/remove-many`,
      method: "DELETE",
      headers: { "Content-Type": "application/json" },
      data: deleteAlbumRecordDto,
    },
    options
  );
};

export const getAlbumControllerRemoveAlbumRecordsMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof albumControllerRemoveAlbumRecords>>,
    TError,
    { data: BodyType<DeleteAlbumRecordDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof albumControllerRemoveAlbumRecords>>,
  TError,
  { data: BodyType<DeleteAlbumRecordDto> },
  TContext
> => {
  const mutationKey = ["albumControllerRemoveAlbumRecords"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof albumControllerRemoveAlbumRecords>>,
    { data: BodyType<DeleteAlbumRecordDto> }
  > = props => {
    const { data } = props ?? {};

    return albumControllerRemoveAlbumRecords(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AlbumControllerRemoveAlbumRecordsMutationResult = NonNullable<
  Awaited<ReturnType<typeof albumControllerRemoveAlbumRecords>>
>;
export type AlbumControllerRemoveAlbumRecordsMutationBody = BodyType<DeleteAlbumRecordDto>;
export type AlbumControllerRemoveAlbumRecordsMutationError = ErrorType<unknown>;

export const useAlbumControllerRemoveAlbumRecords = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof albumControllerRemoveAlbumRecords>>,
      TError,
      { data: BodyType<DeleteAlbumRecordDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof albumControllerRemoveAlbumRecords>>,
  TError,
  { data: BodyType<DeleteAlbumRecordDto> },
  TContext
> => {
  const mutationOptions = getAlbumControllerRemoveAlbumRecordsMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const albumControllerRenameAlbum = (
  renameAlbumDto: BodyType<RenameAlbumDto>,
  options?: SecondParameter<typeof customClient>
) => {
  return customClient<void>(
    {
      url: `/api/album/rename-album`,
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      data: renameAlbumDto,
    },
    options
  );
};

export const getAlbumControllerRenameAlbumMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof albumControllerRenameAlbum>>,
    TError,
    { data: BodyType<RenameAlbumDto> },
    TContext
  >;
  request?: SecondParameter<typeof customClient>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof albumControllerRenameAlbum>>,
  TError,
  { data: BodyType<RenameAlbumDto> },
  TContext
> => {
  const mutationKey = ["albumControllerRenameAlbum"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && "mutationKey" in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof albumControllerRenameAlbum>>,
    { data: BodyType<RenameAlbumDto> }
  > = props => {
    const { data } = props ?? {};

    return albumControllerRenameAlbum(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AlbumControllerRenameAlbumMutationResult = NonNullable<
  Awaited<ReturnType<typeof albumControllerRenameAlbum>>
>;
export type AlbumControllerRenameAlbumMutationBody = BodyType<RenameAlbumDto>;
export type AlbumControllerRenameAlbumMutationError = ErrorType<unknown>;

export const useAlbumControllerRenameAlbum = <TError = ErrorType<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof albumControllerRenameAlbum>>,
      TError,
      { data: BodyType<RenameAlbumDto> },
      TContext
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseMutationResult<
  Awaited<ReturnType<typeof albumControllerRenameAlbum>>,
  TError,
  { data: BodyType<RenameAlbumDto> },
  TContext
> => {
  const mutationOptions = getAlbumControllerRenameAlbumMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};

export const dashboardControllerQueryOverview = (
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>({ url: `/api/dashboard/overview`, method: "GET", signal }, options);
};

export const getDashboardControllerQueryOverviewQueryKey = () => {
  return [`/api/dashboard/overview`] as const;
};

export const getDashboardControllerQueryOverviewQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryOverview>>, TError, TData>
  >;
  request?: SecondParameter<typeof customClient>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDashboardControllerQueryOverviewQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardControllerQueryOverview>>> = ({
    signal,
  }) => dashboardControllerQueryOverview(requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DashboardControllerQueryOverviewQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardControllerQueryOverview>>
>;
export type DashboardControllerQueryOverviewQueryError = ErrorType<unknown>;

export function useDashboardControllerQueryOverview<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
  TError = ErrorType<unknown>,
>(
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryOverview>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryOverview>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryOverview<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryOverview>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryOverview>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryOverview<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryOverview>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useDashboardControllerQueryOverview<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryOverview>>,
  TError = ErrorType<unknown>,
>(
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryOverview>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDashboardControllerQueryOverviewQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const dashboardControllerQueryDeploymentChart = (
  params: DashboardControllerQueryDeploymentChartParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    { url: `/api/dashboard/deployment-chart`, method: "GET", params, signal },
    options
  );
};

export const getDashboardControllerQueryDeploymentChartQueryKey = (
  params: DashboardControllerQueryDeploymentChartParams
) => {
  return [`/api/dashboard/deployment-chart`, ...(params ? [params] : [])] as const;
};

export const getDashboardControllerQueryDeploymentChartQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryDeploymentChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardControllerQueryDeploymentChartQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>
  > = ({ signal }) => dashboardControllerQueryDeploymentChart(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DashboardControllerQueryDeploymentChartQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>
>;
export type DashboardControllerQueryDeploymentChartQueryError = ErrorType<unknown>;

export function useDashboardControllerQueryDeploymentChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryDeploymentChartParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryDeploymentChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryDeploymentChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryDeploymentChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryDeploymentChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useDashboardControllerQueryDeploymentChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryDeploymentChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryDeploymentChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDashboardControllerQueryDeploymentChartQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const dashboardControllerQueryVolumeChart = (
  params: DashboardControllerQueryVolumeChartParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    { url: `/api/dashboard/volume-chart`, method: "GET", params, signal },
    options
  );
};

export const getDashboardControllerQueryVolumeChartQueryKey = (
  params: DashboardControllerQueryVolumeChartParams
) => {
  return [`/api/dashboard/volume-chart`, ...(params ? [params] : [])] as const;
};

export const getDashboardControllerQueryVolumeChartQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryVolumeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDashboardControllerQueryVolumeChartQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>> = ({
    signal,
  }) => dashboardControllerQueryVolumeChart(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DashboardControllerQueryVolumeChartQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>
>;
export type DashboardControllerQueryVolumeChartQueryError = ErrorType<unknown>;

export function useDashboardControllerQueryVolumeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryVolumeChartParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryVolumeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryVolumeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryVolumeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryVolumeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useDashboardControllerQueryVolumeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryVolumeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryVolumeChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDashboardControllerQueryVolumeChartQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const dashboardControllerQueryFeeChart = (
  params: DashboardControllerQueryFeeChartParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    { url: `/api/dashboard/fee-chart`, method: "GET", params, signal },
    options
  );
};

export const getDashboardControllerQueryFeeChartQueryKey = (
  params: DashboardControllerQueryFeeChartParams
) => {
  return [`/api/dashboard/fee-chart`, ...(params ? [params] : [])] as const;
};

export const getDashboardControllerQueryFeeChartQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryFeeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getDashboardControllerQueryFeeChartQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>> = ({
    signal,
  }) => dashboardControllerQueryFeeChart(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DashboardControllerQueryFeeChartQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>
>;
export type DashboardControllerQueryFeeChartQueryError = ErrorType<unknown>;

export function useDashboardControllerQueryFeeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryFeeChartParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryFeeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryFeeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryFeeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryFeeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useDashboardControllerQueryFeeChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryFeeChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof dashboardControllerQueryFeeChart>>, TError, TData>
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDashboardControllerQueryFeeChartQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const dashboardControllerQueryTransactionChart = (
  params: DashboardControllerQueryTransactionChartParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    { url: `/api/dashboard/transaction-chart`, method: "GET", params, signal },
    options
  );
};

export const getDashboardControllerQueryTransactionChartQueryKey = (
  params: DashboardControllerQueryTransactionChartParams
) => {
  return [`/api/dashboard/transaction-chart`, ...(params ? [params] : [])] as const;
};

export const getDashboardControllerQueryTransactionChartQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryTransactionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardControllerQueryTransactionChartQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>
  > = ({ signal }) => dashboardControllerQueryTransactionChart(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DashboardControllerQueryTransactionChartQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>
>;
export type DashboardControllerQueryTransactionChartQueryError = ErrorType<unknown>;

export function useDashboardControllerQueryTransactionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryTransactionChartParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryTransactionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryTransactionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryTransactionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryTransactionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useDashboardControllerQueryTransactionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryTransactionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryTransactionChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDashboardControllerQueryTransactionChartQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const dashboardControllerQueryUserCountChart = (
  params: DashboardControllerQueryUserCountChartParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    { url: `/api/dashboard/user-chart`, method: "GET", params, signal },
    options
  );
};

export const getDashboardControllerQueryUserCountChartQueryKey = (
  params: DashboardControllerQueryUserCountChartParams
) => {
  return [`/api/dashboard/user-chart`, ...(params ? [params] : [])] as const;
};

export const getDashboardControllerQueryUserCountChartQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryUserCountChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardControllerQueryUserCountChartQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>
  > = ({ signal }) => dashboardControllerQueryUserCountChart(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DashboardControllerQueryUserCountChartQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>
>;
export type DashboardControllerQueryUserCountChartQueryError = ErrorType<unknown>;

export function useDashboardControllerQueryUserCountChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryUserCountChartParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryUserCountChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryUserCountChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQueryUserCountChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryUserCountChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useDashboardControllerQueryUserCountChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQueryUserCountChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQueryUserCountChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDashboardControllerQueryUserCountChartQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const dashboardControllerQuerySubmissionChart = (
  params: DashboardControllerQuerySubmissionChartParams,
  options?: SecondParameter<typeof customClient>,
  signal?: AbortSignal
) => {
  return customClient<void>(
    { url: `/api/dashboard/submission-chart`, method: "GET", params, signal },
    options
  );
};

export const getDashboardControllerQuerySubmissionChartQueryKey = (
  params: DashboardControllerQuerySubmissionChartParams
) => {
  return [`/api/dashboard/submission-chart`, ...(params ? [params] : [])] as const;
};

export const getDashboardControllerQuerySubmissionChartQueryOptions = <
  TData = Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQuerySubmissionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  }
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getDashboardControllerQuerySubmissionChartQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>
  > = ({ signal }) => dashboardControllerQuerySubmissionChart(params, requestOptions, signal);

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DashboardControllerQuerySubmissionChartQueryResult = NonNullable<
  Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>
>;
export type DashboardControllerQuerySubmissionChartQueryError = ErrorType<unknown>;

export function useDashboardControllerQuerySubmissionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQuerySubmissionChartParams,
  options: {
    query: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
        TError,
        TData
      >
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQuerySubmissionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQuerySubmissionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
        TError,
        TData
      >
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
          TError,
          Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>
        >,
        "initialData"
      >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useDashboardControllerQuerySubmissionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQuerySubmissionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

export function useDashboardControllerQuerySubmissionChart<
  TData = Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
  TError = ErrorType<unknown>,
>(
  params: DashboardControllerQuerySubmissionChartParams,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof dashboardControllerQuerySubmissionChart>>,
        TError,
        TData
      >
    >;
    request?: SecondParameter<typeof customClient>;
  },
  queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getDashboardControllerQuerySubmissionChartQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
